\clearpage

Глава 4. Листики кода кружат на ветру
=======================================================

<img src="images/chapter_poignant_guide-4.jpg"/>
\Oldincludegraphics[width=1.1in]{images/chapter_poignant_guide-4.jpg}

![Глубоко–глубоко в Пещерах Амбрэ, жил–был Эльф Сколбасой](images/the_elf-1.png)\ 

\clearpage

![и чёрный кот по кличке Негыр](images/the_elf-2.png)\ 

Вообще–то, мы как–раз к Эльфу и пришли, он будет играть важную роль в сегодняшнем уроке. (Кстати, первый раз слышу про разумную колбасу — я думал они только на сковородках шкварчать умеют.)

Девочки, у нас будет посетитель, просьба выглядеть прилично (вот ты, пожалуйста, одень юбку, а не эти ужасные колготы со штрипками!)

А теперь, давайте все вместе поздороваемся с Эльфом Амвросьевичем.

> Здравствуйте Эльф Амвросьевич!!!

Сразу предупреждаю: этот урок более нудный; наберись терпения. Мы будем проходить самую важную часть Руби — принципы программирования.
Я понимаю, тебе хочется поскорее начать писать программы, но без понимания этих принципов выучить Руби невозможно.
Зато когда ты их поймешь, всё остальное будет легко и просто, а главное красиво. Руби будет греть тебе сердце, как мягкий пуховый спальник.



\clearpage

## 1. Шелковичный Листик как символ статуса в Гадюшнике


Эльф Амвросьевич, расскажите пожалуйста нашим ученицам, с какими проблемами столкнулся ваш город, и как введение альтернативной валюты помогло их решить.

![Народ не верит в самоцветы](images/the_elf-3.png)\ 

(На самом деле, всё было по–другому.
Звонит мне однажды Эльф целый день, звонит и звонит, а я трубку не беру.
Тогда он начинает слать кучи СМСок, типа: «Срочно перезвони!!!!!» и «Усатые скупают листву» и «Скидывай камни!!!!» и всё такое.
Тут мне и пришла в голову идея: если народ верит в листики, почему бы их не легализовать?)

После короткого периода паники, курс обмена начал стабилизироваться. Сейчас за один шелковичный листик дают пять болотных самоцветов.
Т.е. ситуация на валютном рынке выглядит так:

    samocvet = 1
    listik = 5

Конечно, для четвертой главы этот пример *совсем уж* детский, но это только начало. Мы присваиваем значения двум *переменным*.
**Знак равенства** — это операция *присваивания*, или *установки*.

После установки значения, переменная `listik` обрела смысл.
Теперь она представляет число `5`, т.е. пять голубых самоцветов.
И вот эта простая операция, мои дорогие, и есть **главный принцип Руби**!
Мы *создаём вещи*, и наделяем их *смыслом*. 
Присваивание переменных — это создание элементарных кирпичиков смысла.
Всё остальное — дело техники.

Ну а что касается Эльфа, ему жаловаться не приходится.
Он открыл самые первые в Гадюшнике пункты обмена валют, и прилично заработал.
(И хотя для нас он маленький гномик, для жителей Страны Болот — он страшный великан!)

![Лаборатория электронных имплантантов](images/the_elf-4.jpg)\ 

Не–не–не–не–не–не! Не надо ей такое видеть. Она растроится, подумает, что это противоестественно, негуманно, грязно, извращённо и так далее, правда, птичечка?

### Давайте я сначала расскажу, чем они там занимаются, тем более, что торопиться нам некуда, ведь это же не фильм.

Давным–давно, ещё до ютьюба, была у меня моя собственная скаковая лошадь. 
Однажды во время скачек она споткнулась, перекувыркнулась раз десять и врезалась в грузчика с ящиком майонеза.
Весь ипподром был залит смесью крови с майонезом.

Ветеринар сразу сказал — лошади хана, ходить не будет, лучше сразу усыпить.
Все четыре ноги переломаны, не оставлять же безногую лошадь. Ну что она будет, сидеть всё время, или ездить на инвалидном кресле? Ветеринар клялся сердцем матери, что ничего нельзя сделать. Мнения разделились: большинство людей ему верили — всё–таки профессионал — но некоторые были слишком упертые и не хотели сдаваться. "Некоторых" было немного — я да Эльф Сколбасой.

И пока остальные закупали венки и медали на похороны моего коня, мы с Эльфом упорно рылись в интернете, и в конце концов нашли выход. Мы взяли живых раков и вживили их коню в культи. Получилось офигенно! У нас снова была лошадь, вернее, лошадинное тело на членистоногой платформе. Она прожила много счастливых лет, тихо ползая во влажной темноте пещер.

Через несколько лет, Эльф основал фирму "Продвинутое Животноводство". Теперь это ведущая в Стране Болот лаборатория по вживлению животным электронных и биологических имплантантов. Они делают новых зверей и разбирают старых на запчасти. Конечно, многое поменялось со времён той первой лошади. В начале, помню, заходит в лабораторию медведь — выходит медведь в тёмных очках. Полная фигня.

Но прошло несколько лет, и вот, заходит в лабораторию краб — выходит краб с собственным ракетным ранцем. Называется «Джеткраб», модель 2004–го года.

И хотя этот бизнес несовсем легальный, сегодня он процветает. Лаборатория в прекрасном состоянии, всё чистое, всё сияет.  У всех работников есть оружие, для обороны. Вдруг кто–то зайдёт без приглашения, например пожарная инспекция, или налоговая. А если закончатся пули, у них есть приказ — бить пистолетами по башке.

Ну что ж, я думаю теперь мы готовы к демонстрации. Показывайте, Эльф Амвросьич.

![Ловим звёздочку](images/the_elf-5a.jpg)\ 

Перевожу на Руби:

       pipe.catch_star
    #    |      |
    # труба.слови_звезду

Всё как обычно: переменная `pipe`, метод `catch_star`.
Кстати, мы, Рубисты, иногда говорим не «вызвать метод объекта А», а «послать сообщение объекту А».
Слева от точки — объект–получатель, справа — сообщение.
Т.е. мы как–бы шлём трубе приказ, в котором написано: «слови нам звёздочку».

В предыдущем примере (с листиками), мы *создавали вещи* и наделяли их *смыслом*.
В этом примере, мы заставляем вещи *действовать*. На этих двух принципах и строится весь Руби:

 1. Создаём вещи.
 2. Заставляем их действовать.

Идём дальше. Допустим, наша программа сработала, и труба подхватила падающую звёздочку. Куда она потом девается?

    star = pipe.catch_star

Как видишь, если на выходе из метода получается какой–то полезный результат, то его можно (но необязательно) положить в переменную.
В данном примере, если под трубу не подставить коробочку, то бедненькая звёздочка упадёт на пол и исчезнет.

(Спрашивается, зачем вызывать метод если тебе не нужен результат? Правильно, умный человек так делать не станет — переводняк!)

![Прикручиваем звёздочку к обезьяне](images/the_elf-5b.jpg)\ 

Всё готово, не будем терять время:

    starmonkey = aggregate.attach( star, monkey )
    #               |        |       |      |
    #            агрегат.прикрепи(звезда,обезьяна)

Объект `агрегат` получает сообщение `прикрепи`. Как он узнает, что к чему прикреплять?
— Это указано в *параметрах*: `star` и `monkey`.
На выходе получаем звездоликую обезьяну и сохраняем её в переменной `starmonkey`.

![Жаба](images/the_elf-5c.png)\ 

Получается вот такая маленькая програмулечка, всего на две строчечки:

    star = pipe.catch_star
    starmonkey = aggregate.attach(star, monkey) + frog
    #                                              |
    #                                            лягушка

Можно даже переписать в одну строчку:

    starmonkey = aggregate.attach( pipe.catch_star, monkey ) + frog

Видишь куда мы переставили `pipe.catch_star`?
Получается, мы подключили выход метода `catch_star` прямо на вход метода `attach`, без промежуточной переменной.
Теперь звёздочка выпадет из трубы прямо в агрегат. Сэкономили коробочку.

![Алё](images/blix-1.png)\ 



\clearpage

## 2. Немного негатива

Честно говоря, квартиры в «Пещерах Амбрэ» довольно хреновые.
Потолки низкие, лифт где–то метр в высоту.
Один чувак загрузил все сумки в лифт, а сам не влез, пришлось ему пешком бежать, пока сумки сами вверх ехали.
Но лестница оказалась настолько низкой, что он шишку набил в темноте. Дом–то в свое время для гномов строился.

А еще помню однажды, открываю кран, а воды нет.
С досады вырвалось из меня заклинание, мол мать его за ногу, даже умыться на ночь невозможно.
Вдруг чувствую, пошло что–то, тёплое и невидимое. На ощупь как вода, а руки сухие остаются.

Всё–таки волшебное это место — Пещеры Амбрэ. Никчемное, но волшебное. Прямо как «nil» в Руби… ;)


### Nil

`nil` (от латинского «нигил», как в слове «нигилизм») — это специальное слово в Руби, обозначающее **пустоту**.
Просьба не путать `nil` и «ноль», потому что ноль это число, а `nil` это **совсем ничто**.

`nil` как зомби: в глазах темно, внутри пусто. Хоть он и ходит, но не может ни думать ни выучить что–нибудь новое.
Не смотря на это, `nil` — очень полезный и встречается много раз в каждой программе.
(Почему все любят скелетов? Потому что они всегда улыбаются!)

Например, возьмём пустой пластиковый стаканчик:

    stakanchik = nil

Строго говоря, переменная `stakanchik` содержит какую–то фигню под названием «нил».
Но ведь «нил» значит «пустота», получается «стаканчик пустоты», то есть «пустой стаканчик».

Другое похожее понятие, знакомое тем читателям которые программируют на других языках, это «неопределённая переменная».
Это когда мы пытаемся прочитать значение переменной, которая никогда раньше не встречалась в программе, и получаем ошибку.
Строго говоря, «неопределённая переменная» просто не существует, и у неё нет и не может быть никакого значения — вот Руби и выдаёт ошибку.

В отличие от «неопределённой переменной», наш `stakanchik` очень даже существует, и у него есть совершенно определённое значение — **пустота**.

### False

<img src="images/blix-neg.png" title="Силуэт кота"/>
\Oldincludegraphics[width=1.6in]{images/blix-neg.png}

_А теперь, обратите внимание направо. Это наш кот Чёрный Негыр (фотография сделана ночью со вспышкой).
Усы как свеженаглаженые стрелочки, глаза спокойные как озеро, хвост как дым из трубы._

А теперь, обрати внимание на *темноту* вокруг Негыра. Знаешь, в искусстве есть такое понятие: «негативное пространство»?
Мне нравится это выражение. Оно хорошо передаёт ощущение отрицания; в пустоте как–бы чувствуется какой–то негатив.
Так и в `nil`е чувствуется что–то негативное, словно какая–то грустная нотка прорывается сквозь его весёлую песенку.

Всё остальное в Руби насквозь пропитано позитивом. Кажется, Руби родился из какой–то очень хорошей мысли, и она проходит через все объекты, строчки, и регэкспы.
И только две вещи мрачно поглядывают из под тёмных капюшонов: `nil` («ничто») и `false` («фальшь»).

Специально чтобы отличать позитив от негатива, в Руби есть оператор `if`.
Пишется он примерно как распространённая форма блока `do`/`end` из предыдущей главы, в том смысле что в конце тоже ставится `end`:

    if stakanchik
        print "Раз мы сюда попали, значит в стаканчике что–то есть."
    end

    # если стаканчик
    #     напечатать "..."
    # конец

Если в `stakanchik`е находится `nil` или `false`, программа перепрыгнет на `end` и на экране ничего не напишется.
Оператор `if`, это как престижный клуб — негативные элементы не пропускаются в защищённый кусок программы.

Мои бедненькие `nil` и `false`, не надо расстраиваться. Специально для вас есть клуб в другом районе, под названием `unless`.
Он, конечно, не такой гламурный как `if`, зато там нормально относятся к таким как вы.
Скажем больше — в нём обслуживают *только* негативных клиентов! (Которых всего два: `nil` и `false`.)

    unless stakanchik
        print "Раз мы сюда попали, значит в стаканчике ничего нет."
    end
    
    # если–не стаканчик
    #     напечатать "..."
    # конец

Если кусок кода, который надо либо *за*пустить либо *про*пустить в зависимости от содержимого переменной, влазит на одну строчку,
то бывает красивее использовать сокращённый вариант операторов `if` и `unless`:

    print "Кажется в стаканчике что–то есть." if stakanchik
    # напечатать "..." если стаканчик
    
    print "Неа, нифига нету." unless stakanchik
    # напечатать "..." если–не стаканчик

А ещё, их можно скомбинировать, чтобы сделать что–то только когда «правда что А и неправда что Б»:

    print "В бокале пусто, пьём из стаканчика" if stakanchik unless bokal
    # напечатать "..." если стаканчик если–не бокал

Иногда такая комбинация читается более естественно и больше подходит по смыслу чем другие варианты.


### True

     face = true
    #  |      |
    # лицо искреннее

Сегодня в столовке я встретил `true`. Терпеть его не могу, уж слишком он *искренний*.
Всегда такой приветливый, спокойный, уверенный в себе.
Высокий, мускулистый, зубы ровные, волосы — кучерявые.
Стоит прямо, ноги на ширине плеч, смотрит в глаза и улыбается.
Того и гляди не сдержится и полетит спасать планету от глобальной катастрофы.

Не люблю людей которые никогда не сомневаются. Они меня нервируют.
Только спросишь его что–нибудь, и он сразу: «Давай я тебе помогу».
А когда он спрашивает «Как дела?», что мне отвечать?!
«Ну, понимаешь, `true`, у меня такая сложная ситуация…».

И конечно–же у него есть знакомые в клубе `if`, поэтому он заходит через служебный вход.
«Тук–тук, можно к вам?» — «А, это ты, `true`, заходи!»
(Это всё потому, что у него *очень* искреннее лицо.)

    print "Заходи!" if true # эти две строчки...
    print "Заходи!"         # ...работают совершенно одинаково

Только в особо важных случаях `true` становится в общую очередь:

    if face == true
        print "Проходите пожалуйста."
    end

**Равно–равно** — это верёвочные барьеры с двух сторон от входа (чтобы толпа с боков не лезла), а `true` спокойно шагает прямо по красной дорожке — его–то точно пропустят!
Задача двойного знака равенства — произвести фейс–контроль. С одной стороны от знака — физиономия посетителя, с другой — критерии установленные хозяином заведения.

И ты, как хозяйка, устанавливаешь эти критерии — кого пускать, кого не пускать. Если `true` для тебя слишком слащавый, можно сказать чтобы пускали только `false`:

    if face == false
        print "Залазь, фальшивая сволочь"
    end

Оператор `unless` из предыдущей секции работает точно так же только наоборот — в обоих случаях ты решаешь кого пускать.
Ну вот, хозяюшка, теперь ты всё знаешь.
Теперь, как говорится, бери и владей.


### Методы и результаты

Хочешь офигительный прикол? **Равно–равно — это метод!**
Представляешь? Его можно вызывать с точкой и скобками, вот так:

    face.==( true )

И этот метод, как в полной, так и в сокращённой форме, выдаёт результат.
*А станет ли умный человек вызывать метод и выбрасывать результат?* Правильно помнишь, не станет — это переводняк! :^)

    if nil.==( true )
        print "Эта строчка никогда не напечатается"
    end

Где в этом примере результат и как он используется?
Мы вызываем метод `==` у объекта `nil` и передаём ему параметр `true`.
Метод `==` сравнивает объект с параметром и возвращает результат сравнения.
В данном случае `nil` и `true` явно не равны, поэтому метод `==` возвращает `false`.
Этот результат идёт в `if`, который, как известно, не пропускает `false`. Поэтому `print` не вызывается. Всё просто.

Идём дальше. Оператор `if` тоже выдаёт результат, хотя он, строго говоря, и не метод:

    na_rabote = true
    email = if na_rabote
              "why@hotelambrose.com"
            else
              "why@gmail.com"
            end

(Как всегда с примерами, сначала попробуй разобраться сама, а потом читай дальше.)
В зависимости от значения переменной `na_rabote`, оператор `if` выполнит один из двух кусков кода.
Тот кусок который выполнился, пойдёт в качестве результата на выход `if`а.
В данном случае, мы точно знаем, что переменная `na_rabote` имеет *положительное* значение, поэтому из `if`а вернётся моё *рабочее* мыло.
Кусок кода между `else` и `end` выполнится только если `if` не сработал (англ. «else» значит «в противном случае»).
Если бы значение переменной `na_rabote` было *отрицательным*, то в переменную `email` попал бы мой *личный* адрес.

Небольшое уточнение: если кусок кода внутри `if`а состоит из нескольких действий, то **на выход пойдёт результат последнего действия**:

    email = if na_rabote
              address = "why"
              address << "@hotelambrose"
              address << ".com"
            end

Что мы тут видим? Внутри `if`а — последовательность из трёх действий.
Сначала мы записываем в переменную `address` моё имя. Потом дописываем домен и «.com».
Здесь, **меньше–меньше — это операция конкатенации**. («Конкатенация» значит сцепление двух строчек.)

Как и операция сравнения `==`, операция конкатенации — на самом деле тоже метод.
Это задание строчке, сидящей в переменной `address`: «вот тебе другая строчка, прилепи её себе к хвосту и выдай нам результат».
Для пущей наглядности, вызовы метода `<<` можно переписать в полной форме — с точкой и скобками:

    email = if na_rabote
              address = "why"
              address.<<( "@hotelambrose" )
              address.<<( ".com" )
            end

Опять же, у каждого метода есть результат. Первый вызов `<<` выдаст «why@hotelambrose».
Обычно, результат нужно записывать в переменную, но в данном случае это делать не обязательно, потому что метод `<<` меняет саму строчку у которой он вызван.
Значит, на момент выполнения второго `<<` в переменной `address` будет уже «why@hotelambrose».
Поэтому, второй вызов метода `<<` выдаст полностью готовый адрес.
А так как это последнее действие в `if`е, то его результат пойдет на выход `if`а, и запишется в переменную `email`.
Что и требовалось доказать!

Теперь такой вопрос: что если `if` не сработал?
В смысле, что вернётся из `if`а, если код внутри него не выполнился, потому что результат проверки оказался отрицательным?
Ничего не вернётся? А что же тогда запишется в переменную? Ничто?
Правильно, ничто, то есть `nil`! 

Вообще–то если вдуматься, `nil` не такая уж бездарная вещь.
В некоторых ситуациях он очень выручает.
Например, когда нужно запрограммировать три варианта ответа: «да», «нет» и «не знаю»:

    print( if na_rabote.nil?
             "Понятия не имею, на работе он или нет."
           elsif na_rabote == true
             "Точно на работе."
           elsif na_rabote == false
             "Ушёл."
           else
             "Ничё не понимаю!"
           end )

Опять–таки, вызов метода это обращение непосредственно к объекту: «Эй, объект, ты случайно не nil?»
На этот вопрос все объекты кроме `nil`а отвечают `false`, то есть «никак нет, вашбродь!»


